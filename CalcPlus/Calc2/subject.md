# Calc Plus

[ANTLR4 Getting Started](https://github.com/antlr/antlr4/blob/master/doc/getting-started.md)의 Expr 예제를 기반으로 조금씩 확장한 언어다.

일반 프로그래밍 언어 개발을 바로 시작할 경우 상당히 많은 문법적 특성도 고려해야 하고, ANTLR 기반의 전단부 해석을 학습하기에 복잡한 부분이 많다.

이에 따라, 계산기 수준의 표현력인 최소한의 언어부터 시작해서, 변수 도입, 입출력까지만 지원하는 언어를 만들려 한다.

## Calc-0

언어 스펙은 예제의 Expr 문법에서 조금 확장한 아래 문법을 참고한다.

1. 코드는 단일 수식으로 끝난다.
2. 하지만 한 수식에는 여러 항의 연산이 가능하다.
3. 사칙연산에 대한 우선순위는 적용된다.
4. 괄호는 연산 우선순위를 강제하기 위해 사용된다.

```antlrv4
grammar CalcPlus;
calc0   :   expr EOF ;
expr    :   expr ('*'|'/') expr # MulDiv
        |   expr ('+'|'-') expr # AddSub
        |   INT                 # Int
        |   '(' expr ')'        # Parens
        ;
WS  : [ \t\r\n]+ -> skip;
INT : [0-9]+ ;
```

* L1의 문법 제목을 `Expr` 대신 `CalcPlus`로 변경
* L2의 프로그램 전체 문법을 `prog` 대신 `calc0`로 변경
* L3~L6 마지막에 `#`으로 시작하는 부분의 Label이 추가
* L8이 원래 `NEWLINE : [\r\n]+ -> skip;`이었음
* L8을 `WS`로 변경하여, 스페이스와 탭도 무시할 수 있게 변경

### 구현 과제 #1

1. ANTLR CLI를 사용하여 lexer, parser 코드를 생성한다.
2. parser 생성 시 visitor, listener 패턴을 모두 지원할 수 있게 생성한다.
3. parser의 visitor, listener를 확장/구현한 구조체/클래스에서 계산을 수행한다.
4. parser의 결과물을 계산 결과로 반환한다.
5. 예시 입력으로 `10 + 2 * (5 - 9 / 3)`가 입력된다면 `14`를 계산해 내야 한다.

힌트: visitor 방식이 직관적임. 하지만 listener로도 구현해 보길 바람.

### 구현 과제 #2

1. ANTLR CLI를 사용하여 lexer, parser 코드를 생성한다.
2. parser 생성 시 visitor, listener 패턴을 모두 지원할 수 있게 생성한다.
3. 현재 문법은 InFix 순서로 수식이 작성되어있는데, 이를 PostFix 순서로 변경해서 출력한다.
4. 예시 입력으로 `10 + 2 * (5 - 9 / 3)`가 입력된다면 `10 2 5 9 3 / - * +`가 출력되어야 한다.

힌트: listener 방식이 직관적임. 하지만 visitor로도 구현해 보길 바람.

### 알아 둘 내용

1. `expr` 규칙에 `|`로 여럿 표시한 것은, `expr`이 여러 방식으로 해석될 수 있다는 뜻이다.
2. `expr`이 재귀적으로 쓰인 것은, 좌항/우항을 재귀적으로 활용할 수 있다는 뜻이다.
3. `expr` 규칙은 위에서부터 아래로 우선순위를 가진다. (현재 사칙연산 우선순위를 구현 중)
4. 괄호 규칙은 맨 아래 있지만, 괄호로 시작하는 규칙이 유일하므로, 의도대로 최우선 처리된다.
5. L3~L6 마지막에 `#`을 추가한 것은 각 규칙의 해석을 추가해준다. (라벨 추가 시 어떤 메서드가 생성되는지 확인해 볼 것)
6. 실제 코드 작업 과정에서 연산자를 가져오는 방법, 좀 더 쉽게 가져올 방법을 생각해볼 것. (ANTLR 문법 수정 필요)

## Calc-1

언어 스펙은 단순한 상수 계산만 가능하던 Calc-0에서 변수 개념을 확장해보자.

1. 변수 개념을 도입한다.
2. 변수는 알파벳으로만 구성한 단어이며, 대소문자를 구분한다.
3. 코드는 변수에 수식 계산 값을 저장하는 문장 여러개로 구성된다. (최소 한 문장, 최대 제한 없음)
4. 변수 값 저장은 C언어와 같이 `변수 = 수식;` 방식으로 값을 변수에 저장한다.
5. 수식은 괄호, 사칙연산이 포함된 Calc-0에 숫자 대신 변수가 들어갈 수 있게 확장한다.
6. `;`으로 각 문장의 종료를 구분한다.

```antlrv4
grammar CalcPlus;
calc0   :   expr EOF ;
expr    :   expr ('*'|'/') expr # MulDiv
        |   expr ('+'|'-') expr # AddSub
        |   INT                 # Int
        |   VAR                 # Var
        |   '(' expr ')'        # Parens
        ;

calc1   :   (stmt)+ EOF;
stmt    :   VAR '=' expr ';'    # ExprAssign
        ;

WS  : [ \t\r\n]+ -> skip;
INT : [0-9]+ ;
VAR : [A-Za-z]+ ;
```

* L6에 `expr`이 `VAR`를 사용할 수 있게 추가
* L10에 Calc-1 프로그램의 문법을 선언
* L11에 변수에 값을 선언하는 문장을 정의
* L16에 변수가 될 수 있는 규칙을 선언

### 구현 과제 #1

1. 각 변수에 값을 계산하여 저장할 수 있게 구현해야 한다.
2. 변수에 값이 저장된 다음 문장부터는 해당 변수를 계산 결과로 해석한다.
3. 수식에 포함된 변수가 처음 선언된 변수인 경우 `0`으로 취급하여 계산한다.
4. 수식 계산중에는 변수의 값이 바뀌지 않는다. 수식의 결과로 변수 값을 저장할 때만 변경된다.
5. 변수에 값을 다시 저장한다면 최근 값으로 덮어쓴다. (변수는 모두 mutable하다.)
6. 프로그램이 끝날 때 까지 선언된 변수 이름과 마지막 값들을 알아낼 수 있어야 한다.

아래는 Calc-1 프로그램 예제와, 각 문장마다 값이 변경되는 예시를 보여준다.  
(문법에는 주석을 지원하지 않지만 해석 편의를 위해 작성한 것이다.)

```
a = 1;          // a == 1
b = a + 2;      // a == 1, b == 3
c = b * 3;      // a == 1, b == 3, c == 9
a = a + 1;      // a == 2, b == 3, c == 9
d = (5 - e) * 2;// a == 2, b == 3, c == 9, d == 10, e == 0
```

문장의 구분은 `;`를 기준으로 하므로, 위 코드와 아래 한 줄 코드는 동일한 코드다.

```
a=1;b=a+2;c=b*3;a=a+1;d=(5-e)*2;
```

힌트: visitor 방식으로 구현을 추천함.

### 구현 과제 #2

1. 프로그램을 계산하진 않아도 된다.
2. 변수에 값이 저장될 때와, 변수가 수식에 사용될 때를 감지한다.
3. 변수가 저장되기 전에 수식에서 사용되는지 확인하여 경고를 출력한다.
4. 경고에는 해당 변수의 위치를 알기 위한 Line, Column 정보도 포함되어야 한다.

아래 예제의 주석처럼 출력하진 않아도 되지만, 주요 내용은 알 수 있어야 한다.

```
a = b + 3; // Line 1 Column 4 : Variable 'b' is not defined.
```

당연히 아래와 같이 같은 변수가 할당과 수식에 사용되어도 할당 전에 접근하면 오류다.

```
a = a + 1; // Line 1 Column 4 : Variable 'a' is not defined.
```

힌트: listener 방식으로 구현을 추천함.

### 알아 둘 내용

1. 프로그램의 시작 지점이 `Calc1`으로 변경되었음.  
   (보통 기존 룰을 변경하지만, 기존 코드 참고 및 하위호환성을 위해 일부러 구분하는 중)
2. `calc1`은 `stmt`가 여러번 반복되므로, visitor의 경우 반복 처리가 필요하다.
3. 값을 할당하는 부분은 값을 반환하지 않는다. visitor의 경우 반환 값 검증 시 구분이 필요하다.

## Calc-2

언어 스펙은 코드의 흐름을 제어할 수 있는 분기문을 추가해보자.

1. 분기문 개념을 도입한다.
2. 분기 조건은 수식과 수식 간의 값이 비교 수식에 일치하는지 기준으로 판단한다.
3. 분기문 문법은 C언어와 동일한 방식으로 `if (cond) {cond_true} else {cond_false}` 방식이다.
4. `if` 조건이 일치하지 않는 `else` 부분은 생략할 수 있다.
5. 분기문의 문맥 구분을 위해 조건부의 `()`도 필수이고, 처리부의 `{}`도 필수다.
6. 조건부의 비교 연산은 `==`, `!=`, `<`, `>`, `<=`, `>=`이 가능하다.
7. 논리 수식간의 연산자는 아직 지원하지 않는다. (`&&`, `||` 없음)

```antlrv4
grammar CalcPlus;
calc0   :   expr EOF ;
expr    :   expr ('*'|'/') expr # MulDiv
        |   expr ('+'|'-') expr # AddSub
        |   INT                 # Int
        |   VAR                 # Var
        |   '(' expr ')'        # Parens
        ;

calc1   :   (stmt)+ EOF;
stmt    :   VAR '=' expr ';'                    # ExprAssign
        |   'if' '(' cond ')' thenBlock=block
            ('else' elseBlock=block)?           # IfElse
        ;

calc2   :   (stmt)+ EOF;
cond    :   expr ('=='|'!='|'>'|'>='|'<'|'<=') expr ;
block   :   '{' (stmt)* '}' ;

WS  : [ \t\r\n]+ -> skip;
INT : [0-9]+ ;
VAR : [A-Za-z]+ ;
```

* L12,13에 stmt가 가능한 예시로 if-else 문법을 추가
* L16에 Calc2 프로그램의 문법을 선언
* L17에 조건문 표기법으로 크기비교 연산들을 정의
* L18에 if-else에 들어갈 블록을 선언

### 구현 과제 #1

1. 각 변수에 값을 계산하여 저장할 수 있게 구현해야 한다.
2. 변수에 값이 저장된 다음 문장부터는 해당 변수를 계산 결과로 해석한다.
3. 수식에 포함된 변수가 처음 선언된 변수인 경우 `0`으로 취급하여 계산한다.
4. 수식 계산중에는 변수의 값이 바뀌지 않는다. 수식의 결과로 변수 값을 저장할 때만 변경된다.
5. 변수에 값을 다시 저장한다면 최근 값으로 덮어쓴다. (변수는 모두 mutable하다.)
6. 분기문을 구현하여 조건에 따라 if-else(생략 가능) 부분만 실행한다.
7. 분기문 블록에 대한 변수 scope 개념은 도입하지 않아도 된다.
8. 프로그램이 끝날 때 까지 선언된 변수 이름과 마지막 값들을 알아낼 수 있어야 한다.

아래는 Calc-2 프로그램 예제와, 각 문장마다 값이 변경되는 예시를 보여준다.  
(문법에는 주석을 지원하지 않지만 해석 편의를 위해 작성한 것이다.)

```
a = 1;          // a == 1
if (a >= 1) {   // true, executing block
    b = a + 2;  // a == 1, b == 3
    c = b * 3;  // a == 1, b == 3, c == 9
} else {        // false, skipping block
    b = a;
    c = b;
}
a = a + 1;      // a == 2, b == 3, c == 9
d = (5 - e) * 2;// a == 2, b == 3, c == 9, d == 10, e == 0
```

힌트: 알아서 결정해보자

## Calc-3

변수의 값 입력과 출력을 도입해보자.

1. 내장 함수 개념을 도입한다. `read`, `write` 함수가 추가된다.
2. 함수 호출은 C언어를 비롯한 대부분의 프로그래밍 언어 처럼 `read()`방식으로 처리된다.
3. `a = read()` 방식으로 `read`는 인자가 없고, 입력받은 숫자를 반환한다.
4. `read()`는 즉시 변수로 값을 저장해야 하며, 수식의 일부가 될 수 없다. (읽기 순서 모호성 방지)
5. `write(b)`, `write(1+2)` 방식으로 `write`는 인자로 수식을 입력받고, 결과는 반환하지 않는다.

```antlrv4
grammar CalcPlus;
calc0   :   expr EOF ;
expr    :   expr ('*'|'/') expr # MulDiv
        |   expr ('+'|'-') expr # AddSub
        |   INT                 # Int
        |   VAR                 # Var
        |   '(' expr ')'        # Parens
        ;

calc1   :   (stmt)+ EOF;
stmt    :   VAR '=' expr ';'                    # ExprAssign
        |   VAR '=' 'read' '(' ')' ';'          # ReadAssign
        |   'if' '(' cond ')' thenBlock=block
            ('else' elseBlock=block)?           # IfElse
        |   'write' '(' expr ')' ';'            # Write
        ;

calc2   :   (stmt)+ EOF;
cond    :   expr ('=='|'!='|'>'|'>='|'<'|'<=') expr ;
block   :   '{' (stmt)* '}' ;

calc3   :   (stmt)+ EOF;

WS  : [ \t\r\n]+ -> skip;
INT : [0-9]+ ;
VAR : [A-Za-z]+ ;
```
* L12에 `read()`를 할 수 있는 문법을 추가 (수식의 일부가 되는걸 막기 위해 변수에 저장)
* L14에 `write()`를 할 수 있는 문법을 추가 (문장 중 하나로 함수 호출만 지원, 값은 수식이 될 수 있음)
* L22에 Calc3 프로그램의 문법을 선언 (Calc1, Calc2와 동일) 

### 구현 과제 #1

1. Hello world처럼 지정된 값을 출력하는 프로그램을 실행할 수 있게 한다.
2. Echo처럼 변수를 입력 받고 즉시 다시 출력하는 프로그램을 실행할 수 있게 한다.
3. Calc-3를 지원하는 인터프리터가 CLI 실행 파일/script 파일로 생성되어야 한다.
4. `$ calc3 test.cp`처럼 인터프리터 실행의 인자로 Calc3 소스 경로를 입력받는다.
5. 이후 `read()`에 의한 사용자의 입력은 stdin으로 입력받는다.
6. `write()`에 의한 프로그램의 출력은 stdout으로 출력한다.
7. `read()`가 실패하는 경우 0으로 취급 혹은 여러 형태로 프로그램을 강제 종료한다. (stdin의 입력이 더 없거나, 유효한 숫자가 아님)

고려사항

* 각 언어의 test framework를 최대한 활용하고, CLI는 단순한 연결 위주로 개발한다.
* 각 테스트의 입력은 코드와 사용자 입력 값이며, 결과는 프로그램의 출력과 비교한다.
* 이번 과제는 문법과 시맨틱의 난이도보다 IO 연동 처리에 집중하는 과제다.

### 구현 과제 #2

구현과제 1번은 Hello world 부터 Echo까지 입출력에만 집중했다.
이제 기존 Calc-2까지 구현했던 수식 연산, 변수 읽기/쓰기, 분기문 까지 연동한다.
